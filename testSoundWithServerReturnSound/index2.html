<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width" />
    <title>Web Audio API: AudioBuffer</title>
  </head>

  <body>
    <h1>Web Audio API: AudioBuffer</h1>
    <button>Make white noise</button>
    <form>
        <input type="file" id="my-file-input" multiple="multiple" accept="audio/*">
    </form>
  </body>
  <script>
    const button = document.querySelector("button");

    let audioCtx;

    // Stereo
    let channels = 1;

    function init() {
      audioCtx = new AudioContext();
    }

    button.onclick = () => {
      if (!audioCtx) {
        init();
      }

      async function getData(file) {
        let audioData = await file.arrayBuffer();

        let audioCtx = new AudioContext({sampleRate: 10000}); // 10000

        let decodedData = await audioCtx.decodeAudioData(audioData); // audio is resampled to the AudioContext's sampling rate

        console.log(decodedData.length, decodedData.duration, decodedData.sampleRate, decodedData.numberOfChannels);

        return decodedData.getChannelData(0); 
    }

    const frameCount = 10000 * 8;

    const buffer = new AudioBuffer({
      numberOfChannels: channels,
      length: frameCount,
      sampleRate: 10000,
    });

    async function addToBuf() {
        const files = document.getElementById('my-file-input').files;

        for (let kk = 0; kk < 8; kk++) {
            let res = await getData(files[kk]);
            console.log(res);


            for (let channel = 0; channel < channels; channel++) {
                // This gives us the actual array that contains the data
                const nowBuffering = buffer.getChannelData(channel);
                for (let i = 0; i < 10000; i++) {
                    // Math.random() is in [0; 1.0]
                    // audio needs to be in [-1.0; 1.0]
                    nowBuffering[i + kk * 10000] = res[i];
                  }
            }
        }
        
    }

    addToBuf();

      // Create an empty two second stereo buffer at the
      // sample rate of the AudioContext

      // Fill the buffer with white noise;
      // just random values between -1.0 and 1.0
     /* for (let channel = 0; channel < channels; channel++) {
        // This gives us the actual array that contains the data
        const nowBuffering = buffer.getChannelData(channel);
        
        for (let i = 0; i < frameCount; i++) {
          // Math.random() is in [0; 1.0]
          // audio needs to be in [-1.0; 1.0]
          nowBuffering[i] = Math.random() * 2 - 1;
        }
      }*/

      // Get an AudioBufferSourceNode.
      // This is the AudioNode to use when we want to play an AudioBuffer
      const source = audioCtx.createBufferSource();
      // Set the buffer in the AudioBufferSourceNode
      source.buffer = buffer;
      // Connect the AudioBufferSourceNode to the
      // destination so we can hear the sound
      source.connect(audioCtx.destination);
      // start the source playing
      source.start();





      function make_download(abuffer, total_samples) {

        // get duration and sample rate
        var duration = abuffer.duration,
            rate = abuffer.sampleRate,
            offset = 0;
    
        var new_file = URL.createObjectURL(bufferToWave(abuffer, total_samples));
    
        var download_link = document.getElementById("download_link");
        download_link.href = new_file;
        var name = "merged.wav";
        download_link.download = name;
    
    }

    audioCtx.startRendering().then(function(renderedBuffer) {
  
        make_download(renderedBuffer, offlineAudioCtx.length);
      });
    };
  </script>
</html>